<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html" charset="UTF-8">

    <title>Marvel Museum</title>

    <link rel="icon" type="image/png" href="./images/favicon.png">

    <link rel="stylesheet" href="./style.css">

    <div id="background_menu"></div>
    <div id="menu">
        <div id="img_container">
            <img src="./images/marvel.jpg">
        </div>
        <div id="content">
            <h1>Marvel Museum Walkthrough <br> with Three.js</h1>
            <div>
                <p>Instructions:</p>
                <p>Use W/A/S/D or Arrows to Move Around, Space and Shift to go Up and Down</p>
                <p>Mouse to Control the Camera</p>
            </div>
            <div id="play_button">
                <p>ENTER THE MUSEUM</p>
            </div>
        </div> 
      </div>

</head>



<body>
    <script async src="./bib/helper.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://threejs.org/build/three.module.js",
                "three/addons/": "https://threejs.org/examples/jsm/"
            }
        }
    </script>

    <script type="module">

        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import Stats from "three/addons/libs/stats.module.js";
        import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
        import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
        import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        const loader = new GLTFLoader();
    

        // ************************** //
        // Add Scene
        // ************************** //
        const scene = new THREE.Scene();


        // ************************** //
        // Add Camera
        // ************************** //
        const aspectRatio = window.innerWidth / window.innerHeight;
        const camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
        scene.add(camera);
        camera.position.z = 5;


        // ************************** //
        // Add Renderer
        // ************************** //
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        document.body.appendChild(renderer.domElement);



        // ************************** //
        // Add Listener to Move
        // ************************** //
        document.addEventListener('keydown', onKeyDown, false);


        // ************************** //
        // Stuff to Move Camera
        // ************************** //

        let isDragging = false;
        let previousMousePosition = {
            x: 0,
            y: 0
        };

        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('mouseup', onMouseUp, false);

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };

                // Rodar a câmera com base no movimento horizontal do mouse
                const theta = 0.001 * deltaMove.x;

                camera.rotation.y += theta;

                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        }


        function onMouseUp(event) {
            isDragging = false;
        }


        // ************************** //
        // Add Player Position
        // ************************** //
        const playerPos = new THREE.Vector3(0, 3, 5);


        // ************************** //
        // Add Textures
        // ************************** //
        const textureLoader = new THREE.TextureLoader();

        const floorTexture = textureLoader.load('./images/floor.jpg');
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(20, 20);

        const wallsTexture = textureLoader.load('./images/wall.png');
        wallsTexture.wrapS = THREE.RepeatWrapping;
        wallsTexture.wrapT = THREE.RepeatWrapping;
        wallsTexture.repeat.set(8, 8);

        const ceilingTexture = textureLoader.load('./images/ceiling.png');
        ceilingTexture.wrapS = THREE.RepeatWrapping;
        ceilingTexture.wrapT = THREE.RepeatWrapping;
        ceilingTexture.repeat.set(4, 4);


        // ************************** //
        // Add Floor
        // ************************** //
        const planeGeometry = new THREE.PlaneGeometry(60, 45);
        const planeMaterial = new THREE.MeshBasicMaterial({ map: floorTexture, side: THREE.DoubleSide});
        const floorPlane = new THREE.Mesh(planeGeometry, planeMaterial); 

        floorPlane.rotation.x = Math.PI / 2; 
        floorPlane.position.y = -Math.PI; 
        scene.add(floorPlane);


        // ************************** //
        // Add Walls
        // ************************** //
        let wallGroup = new THREE.Group(); 
        scene.add(wallGroup);


        const planeGeo = new THREE.PlaneGeometry(60, 45);
        const planeGeo2 = new THREE.PlaneGeometry(45, 45);
        const planeMat = new THREE.MeshBasicMaterial({map: wallsTexture,side: THREE.DoubleSide});


        // Front Wall
        const frontWall = new THREE.Mesh(planeGeo,planeMat);
        frontWall.position.z = -22.5; 

        // Back Wall
        const backWall = new THREE.Mesh(planeGeo,planeMat);
        backWall.position.z = 22.5; 


        // Left Wall
        const leftWall = new THREE.Mesh(planeGeo2,planeMat);
        leftWall.rotation.y = Math.PI / 2; 
        leftWall.position.x = -30; 

        // Right Wall
        const rightWall = new THREE.Mesh(planeGeo2,planeMat);
        rightWall.position.x = 30;
        rightWall.rotation.y = Math.PI / 2; 

        wallGroup.add(frontWall, leftWall, rightWall, backWall);


        for (let i = 0; i < wallGroup.children.length; i++) {
        wallGroup.children[i].BBox = new THREE.Box3();
        wallGroup.children[i].BBox.setFromObject(wallGroup.children[i]);
        }



          // ************************** //
        // Add Ambient Lights
        // ************************** //
        const ambientLight = new THREE.PointLight(0xffffff);
        ambientLight.position.copy(camera.position);
        scene.add(ambientLight);

        const ambientLight2 = new THREE.PointLight(0xffffff);
        ambientLight2.position.set(29, 10, -15);
        scene.add(ambientLight2);

        const ambientLight3 = new THREE.PointLight(0xffffff);
        ambientLight3.position.set(28, 10, -15);
        scene.add(ambientLight3);

        const ambientLight4 = new THREE.PointLight(0xffffff);
        ambientLight4.position.set(28, 10, -20);
        scene.add(ambientLight4);

        // ************************** //
        // Add Sun Light
        // ************************** //
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.y = 0
        scene.add(sunLight);



        // Variável para controlar o estado da luz
        var isLightOn = false;

        // Função para alternar o estado da luz
        function toggleLight() {
            isLightOn = !isLightOn;
            ambientLight.visible = isLightOn;
            ambientLight2.visible = isLightOn;
            ambientLight3.visible = isLightOn;
            ambientLight4.visible = isLightOn;
            sunLight.visible = isLightOn;
        }

        // Adicionar um ouvinte de eventos para o pressionamento da tecla
        document.addEventListener('keydown', function (event) {
            if (event.key === 'L' || event.key === 'l') {
                toggleLight();
            }
        });


    
        // Criar o material com a textura
        var texture12 = new THREE.TextureLoader().load('/images/marmore.jpeg');
        var material12 = new THREE.MeshBasicMaterial({ map: texture12 });
        var geometry12 = new THREE.BoxGeometry(4, 3, 4);
        var cube12 = new THREE.Mesh(geometry12, material12);

        // Posicionar o cubo abaixo do objeto
        cube12.position.set(28, -2, -15);

        // Adicionar o cubo à cena
        scene.add(cube12);

        loader.load(
            './models/iron_man/scene.gltf',
            
            function ( gltf ) {
                gltf.scene.position.set(28, -0.5, -15);
                gltf.scene.scale.set(0.0038, 0.0038, 0.0038);
                gltf.scene.rotation.y = THREE.MathUtils.degToRad(-90);

                scene.add( gltf.scene );

            }
        );

         // Criar o material com a textura
         var texture12 = new THREE.TextureLoader().load('/images/marmore.jpeg');
        var material12 = new THREE.MeshBasicMaterial({ map: texture12 });
        var geometry12 = new THREE.BoxGeometry(4, 3, 4);
        var cube12 = new THREE.Mesh(geometry12, material12);

        // Posicionar o cubo abaixo do objeto
        cube12.position.set(28, -2, -5);

        // Adicionar o cubo à cena
        scene.add(cube12);

        loader.load(
            './models/spider/scene.gltf',
            
            function ( gltf ) {
                gltf.scene.position.set(28, -0.5, -5);
                gltf.scene.scale.set(0.052, 0.052, 0.052);
                gltf.scene.rotation.y = THREE.MathUtils.degToRad(-90);

                scene.add( gltf.scene );

            }
        );

         // Criar o material com a textura
         var texture12 = new THREE.TextureLoader().load('/images/marmore.jpeg');
        var material12 = new THREE.MeshBasicMaterial({ map: texture12 });
        var geometry12 = new THREE.BoxGeometry(4, 3, 4);
        var cube12 = new THREE.Mesh(geometry12, material12);

        // Posicionar o cubo abaixo do objeto
        cube12.position.set(28, -2, 5);

        // Adicionar o cubo à cena
        scene.add(cube12);

        loader.load(
            './models/rocket/scene.gltf',
            
            function ( gltf ) {
                gltf.scene.position.set(29, -0.5, 5);
                gltf.scene.scale.set(4, 4, 4);
                gltf.scene.rotation.y = THREE.MathUtils.degToRad(170);

                scene.add( gltf.scene );

            }
        );

        loader.load(
            './models/groot/scene.gltf',
            
            function ( gltf ) {
                gltf.scene.position.set(26.5, -0.3, 5);
                gltf.scene.scale.set(400, 400, 400);
                gltf.scene.rotation.y = THREE.MathUtils.degToRad(-90);

                scene.add( gltf.scene );

            }
        );


        // ************************** //
        // Add Ceiling
        // ************************** //
        const planeGeometry2 = new THREE.PlaneGeometry(60, 45); 
        const planeMateria2 = new THREE.MeshBasicMaterial({map: ceilingTexture, side: THREE.DoubleSide});
        const ceilingPlane = new THREE.Mesh(planeGeometry2, planeMateria2);

        ceilingPlane.rotation.x = Math.PI / 2; 
        ceilingPlane.position.y = 12;
        scene.add(ceilingPlane);


        // ************************** //
        // Method to Move Character and Avoid Crossing Walls
        // ************************** //

        function onKeyDown(event) {
            const movementSpeed = 1;

            const frontDirection = new THREE.Vector3(0, 0, -1);
            const sideDirection = new THREE.Vector3(-1, 0, 0);

            const frontMovement = frontDirection.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
            const sideMovement = sideDirection.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);

            switch (event.keyCode) {
                case 83: // w
                case 40: // up arrow
                    if (playerPos.z - movementSpeed >= (wallGroup.children[0].BBox.max.z) + movementSpeed && playerPos.y + 1 <= ceilingPlane.position.y) {
                        playerPos.add(frontMovement.multiplyScalar(-movementSpeed));
                    }
                    break;
                case 87: // s
                case 38: // down arrow
                    if (playerPos.z + movementSpeed <= wallGroup.children[3].BBox.min.z && playerPos.y - 1 >= floorPlane.position.y) {
                        playerPos.add(frontMovement.multiplyScalar(movementSpeed));
                    }
                    break;
                case 68: // a
                case 39: // left arrow
                    if (playerPos.x - movementSpeed >= wallGroup.children[1].BBox.max.x && playerPos.y + 1 <= ceilingPlane.position.y) {
                        playerPos.add(sideMovement.multiplyScalar(-movementSpeed));
                    }
                    break;
                case 65: // d
                case 37: // right arrow
                    if (playerPos.x + movementSpeed <= wallGroup.children[2].BBox.min.x && playerPos.y + 1 <= ceilingPlane.position.y) {
                        playerPos.add(sideMovement.multiplyScalar(movementSpeed));
                    }
                    break;
                case 32: // space
                    if (playerPos.y + 1 <= ceilingPlane.position.y - 1) {
                        playerPos.y += 1;
                    }
                    break;
                case 16: // shift
                    if (playerPos.y - 1 >= floorPlane.position.y + 4) {
                        playerPos.y -= 1;
                    }
                    break;
            }
        }


        // ************************** //
        // Add Paintings
        // ************************** //

        const paintingWidth = 12; 
        const paintingHeight = 8; 
        const frameMaterial = new THREE.MeshBasicMaterial({ color: 0x404040 });
        const frameGeometry = new THREE.BoxGeometry(12.5, 8.5, 0.00001);


        const paintingTexture = new THREE.TextureLoader().load('./images/captain_america_1.jpg');
        const paintingGeometry = new THREE.PlaneGeometry(paintingWidth, paintingHeight);
        const paintingMaterial = new THREE.MeshBasicMaterial({ map: paintingTexture, side: THREE.FrontSide });
        const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
        painting.position.set(-22, 4.5, -22.48); 
        scene.add(painting);

        const frame = new THREE.Mesh(frameGeometry, frameMaterial);
        frame.position.set(-22, 4.5, -22.49);
        scene.add(frame);


        const paintingTexture2 = new THREE.TextureLoader().load('./images/capitamarvel.jpg'); // Load painting texture
        const paintingGeometry2 = new THREE.PlaneGeometry(paintingWidth, paintingHeight);
        const paintingMaterial2 = new THREE.MeshBasicMaterial({ map: paintingTexture2, side: THREE.FrontSide });
        const painting2 = new THREE.Mesh(paintingGeometry2, paintingMaterial2);
        painting2.position.set(-7.5, 4.5, -22.48); 
        scene.add(painting2);

        const frame2 = new THREE.Mesh(frameGeometry, frameMaterial);
        frame2.position.set(-7.5, 4.5, -22.49);
        scene.add(frame2);


        const paintingTexture3 = new THREE.TextureLoader().load('./images/iron-man-1.jpg'); // Load painting texture
        const paintingGeometry3 = new THREE.PlaneGeometry(paintingWidth, paintingHeight);
        const paintingMaterial3 = new THREE.MeshBasicMaterial({ map: paintingTexture3, side: THREE.FrontSide });
        const painting3 = new THREE.Mesh(paintingGeometry3, paintingMaterial3);
        painting3.position.set(7.5, 4.5, -22.48); 
        scene.add(painting3);

        const frame3 = new THREE.Mesh(frameGeometry, frameMaterial);
        frame3.position.set(7.5, 4.5, -22.49);
        scene.add(frame3);


        const paintingTexture4 = new THREE.TextureLoader().load('./images/hulk.jpg'); // Load painting texture
        const paintingGeometry4 = new THREE.PlaneGeometry(paintingWidth, paintingHeight);
        const paintingMaterial4 = new THREE.MeshBasicMaterial({ map: paintingTexture4, side: THREE.FrontSide });
        const painting4 = new THREE.Mesh(paintingGeometry4, paintingMaterial4);
        painting4.position.set(22, 4.5, -22.48); 
        scene.add(painting4);

        const frame4 = new THREE.Mesh(frameGeometry, frameMaterial);
        frame4.position.set(22, 4.5, -22.49);
        scene.add(frame4);



        let render = function () {

        renderer.render(scene, camera);
        camera.position.copy(playerPos);

        window.addEventListener('resize', function() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();
        })

        requestAnimationFrame(render);
        };

        render();


    </script>  
    
    
</body>

</html>
